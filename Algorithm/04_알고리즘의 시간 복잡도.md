# 알고리즘의 시간 복잡도 분석
입력의 크기가 작으면 다른 부분이 갖는 비중이 클 수 있지만,  
입력의 크기가 크면 **반복문이 수행되는 횟수**가 수행시간을 좌우한다.

### 선형 시간 알고리즘 : O(N)
직선 그래프, 좋은 알고리즘  
시간에 따라 변화하는 값들을 관찰할 때 유용 ex) GDP, 주식의 가격 등

### 선형 이하 시간 알고리즘  
입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘

- 이진 탐색(binary search) : O(logN)  
N을 계속 절반으로 나눠서 1이하가 될 때까지 반복하는 알고리즘

### 다항 시간 알고리즘   : O(N<sup>M</sup>)
N의 거듭제곱들로 이루어진 다항식으로 표현할 수 있는 알고리즘

### 지수 시간 알고리즘 : O(2<sup>N</sup>)
N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘  
입력으로 주어진 숫자의 개수가 아니라 그 크기에 따라 수행 시간이 달라지는 알고리즘 ex) 소인수 분해  
전체 시간에 엄청난 영향을 미침 (다항 시간보다 훨씬 빠르게 증가)

### 상수 시간 알고리즘 : O(1)
입력의 크기와 상관없이 항상 같은 시간이 걸리는 알고리즘

#### O(1) < O(logN) < O(N) < O(NlogN) < O(N<sup>M</sup>) < O(2<sup>N</sup>) < O(N! )

## 시간 복잡도(Time Complexity)
알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것  
- 더 작게 쪼갤 수 없는 최소 크기의 연산  
- 시간 복잡도가 높다는 말은 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다는 의미  
- 시간 복잡도가 낮은 알고리즘은 입력이 커지면 커질수록 더 효율적이다.  
- 시간 복잡도가 낮다고 해서 언제나 더 빠른 것은 아니다. (입력의 크기가 충분히 작을 경우에는 반대가 될 수도 있다. -> 그래프로 확인)

#### 입력의 크기뿐만 아니라 종류에 따라서도 수행 시간이 달라진다. ex) 배열
- best-case(최선의 수행 시간)
- worst-case(최악의 수행 시간)
- average-case(평균적인 경우의 수행 시간)  

예제
```java
// selection sort(선택 정렬)
private static void selectionSort(int[] arr) {
    int min, temp;
    for (int i = 0; i < arr.length - 1; i++) {
        min = i;
        for (int j = i + 1; j < arr.length; j++) {
            // 현재 위치와 비교하여 가장 작은 값을 찾는다.  
            if (arr[j] < arr[min]) {
            min = j;
            }
        }
        temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
    }
}

// insertion sort(삽입 정렬)
private static void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int temp = arr[i];
        // i보다 작은 값이 나올때까지 밀어내고 적절한 위치에 삽입한다. 
        int j = i;
        while (j > 0 && arr[j - 1] > temp) {
            arr[j] = arr[j - 1];
            j--;
        }
        arr[j] = temp;
    }
}
```
selection sort는 최대 O(N)번 실행되는 for문이 두 개 겹쳐 있기 때문에 O(N<sup>2</sup>)이다.  
insertion sort는 best-case가 이미 정렬된 배열일 경우 while문이 O(1), for문이 O(N)으로 O(N)이지만, worst-case로 역순으로 정렬된 배열일 경우 while문도 O(N)이므로 O(N<sup>2</sup>)이 된다.

### Big-O Notation
주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법 => 점근적 시간 표기  
함수의 상한을 나타낸다.
> 아주 큰 N<sub>0</sub>와 C(N<sub>0</sub>, C>0)를 적절히 선택하면 N<sub>0</sub><=N인 모든 N에 대해 |f(N)|<=C*|g(N)|이 참이 되도록 할 수 있다.  

### 계산 복잡도의 종류(Complexity Class)
계산 복잡도 이론에서 문제의 난이도는 빠른 알고리즘이 있는 문제는 계산적으로 쉽고, 빠른 알고리즘이 없는 문제는 계산적으로 어렵다고 말한다.  
일반적으로 다항 시간 알고리즘이나 그보다 빠른 알고리즘들만 빠르다고 한다.
- P(Polynomial)  
다항 시간 알고리즘이 존재하는 문제들의 집합
- NP(Non-Polynomial)  
다항 시간 알고리즘이 존재하는지 여부가 알려지지 않은 문제들의 집합  
비다항 즉, 다항 시간 알고리즘이 존재하지 않는 문제들의 집합이 아님  
(답이 주어졌을 때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제)
- NP Hard  
모든 NP문제 이상으로 어려운 문제  
NP에 속하는 모든 문제에 대해 다른 문제로 reducible되는 문제 (?)
- NP Complete  
NP-Hard문제이면서 NP인 문제

P문제는 NP문제에 포함된다.

#### P=NP ?
NP-Hard문제 중 하나를 다항 시간에 풀 수 있다면, 이 경우 NP에 속한 모든 문제를 다항 시간에 해결할 수 있으므로 P=NP임을 알 수 있다.  
반대로 NP문제 중 하나를 골라 P에 포함되어 있지 않음 즉, 다항 시간에 푸는 방법이 없음을 증명하면 P≠NP임을 알 수 있다.  
이 문제는 아직까지 미해결이다.

----
#algorithm/알고리즘문제해결전략