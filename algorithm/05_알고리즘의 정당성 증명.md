# 알고리즘의 정당성 증명
알고리즘의 증명을 공부하면 알고리즘을 유도하는 데 결정적인 통찰을 얻을 수 있다.

### 수학적 귀납법과 반복문 불변식
- 수학적 귀납법  
반복적인 구조를 갖는 명제들을 증명하는 데 유용라게 사용되는 증명 기법
    1. 단계 나누기
    2. 첫 단계 증명 - 첫 단계의 증명이 성립함을 보임
    3. 귀납 증명 - 한 단계의 증명이 성립하면, 다음 단계도 성립함을 보임
> <사다리타기 게임의 1:1 대응 증명> 
> 1. 텅 빈 N개의 세로줄에서 원하는 가로줄을 긋는 것을 한 단계로 나눔
> 2. 텅 빈 N개에서는 항상 출발(위)과 도착(아래)이 1:1 대응이다.
> 3. 가로줄을 그어도 연결된 두 세로줄의 결과가 뒤바뀌기 때문에 1:1 대응이 유지된다.  
> 
> 따라서 귀납법에 의해 가로줄만을 상용하는 사다리타기는 항상 1:1로 대응이 된다.

- 반복문 불변식  
반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건  
따라서 반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고 성립해야 한다.
    1. 반복문 진입시에 불변식이 성립함을 보임
    2. 반복문 내용이 불변식을 깨뜨리지 않음을 보임 (반복문 내용이 시작할 때 불변식이 성립했다면 끝날 때도 항상 성립함을 보임)
    3. 반복문 종료시에 불변식에 성립하면 항상 우리가 정답을 구했음을 보임
```
// (*) 불변식은 여기에서 성립해야 한다.
while(어떤 조건) {
    // 반복문 내용의 시작
    ..
    // 반복문 내용의 끝
    // (**) 불변식은 여기에서도 성립해야 한다.
}
```  

-  이진 탐색과 반복문 불변식
```java
// 필수 조건: arr은 오름차순으로 정렬되어 있다.
// 결과: arr[i-1] < x <= arr[i]인 i를 반환한다.
// 이때 arr[-1] = 음의 무한대, arr[n] = 양의 무한대라고 가정한다.
private static int binsearch(int arr[], int target) {
    int lo = -1;
    int hi = arr.length;
    // 반복문 불변식1: lo < hi
    // 반목문 불변식2: arr[lo] < x <= arr[hi]
    // (*) 불변식은 여기서 성립해야 한다.
    while (lo + 1 < hi) {
        int mid = (lo + hi) / 2;
        if (arr[mid] < target) {
            lo = mid;
        } else {
            hi = mid;
        }
        // (**) 불변식은 여기서도 성립해야 한다.
    }
    return hi;
}
```
> **초기조건**  
> while문이 시작할 때 lo와 hi가 -1과 arr.length(n)로 초기화된 상태, 만약 n=0이라면 while문을 건너뛰기 때문에 불변식1은 항상 성립한다. -1과 n번째 원소를 음/양의 무한대라고 가정하므로 불변식2도 성립한다.  
> **유지조건**  
> while문 내부가 불변식을 깨뜨리지 않음을 보이면 된다.  
> while문 내부로 들어왔다는 것은 lo와 hi가 2이상 차이난다는 것이므로 불변식1은 유지된다. 불변식2를 if-else문 조건과 합치면 성립한다.


- 삽입 정렬과 반복문 불변식
```java
private static void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int temp = arr[i];
        // 불변식1: arr[0..i-1]은 이미 정렬되어 있다.
        // arr[0..i-1]에서 arr[i]를 끼워넣는다.
        int j = i;
        while (j > 0 && arr[j - 1] > arr[j]) {
            // 불변식2: arr[j+1..i]의 모든 원소는 arr[j]보다 크다.
            // 불변식3: arr[0..i]구간은 arr[j]를 제외하면 정렬되어 있다.
            arr[j] = arr[j - 1];
            j--;
        }
        arr[j] = temp;
    }
}
```
> **불변식1 초기조건**  
> 반복문이 시작할 때 i=0이면 비어있으니 항상 정렬되어 있다.  
> **불변식1 유지조건**  
> while문의 정당성을 증명해 for문이 종료할 때 불변식이 깨지지 않고 유지됨을 보인다.  
> **불변식2 초기조건**  
> while문 진입시에 arr[j+1..i]구간은 빈구간이므로 참이다.  
> **불변식2 유지조건**  
> while문이 실행되었다는 것은 arr[j-1] > arr[j]라는 의미이므로, 이 둘을 교체하고 j를 1 줄이면 여전히 참이다.  
> **불변식3 초기조건**  
> 불변식1에 의해 구간 arr[0..i-1]는 정렬되어 있으니 while문 진입시에 3은 항상 참이다.  
> **불변식3 유지조건**  
> arr[j]를 이전 원소와 교체한다고 해도 나머지 원소들의 상대적 순서는 변하지 않기 때문에 항상 유지된다.  
>   
> 불변식2,3의 증명이 항상 arr[0..i]를 정렬된 상태라는 것을 보야주므로 불변식1의 유지 조건이 되기 때문에 insertion sort의 정당성을 증명할 수 있다.

### 귀류법
원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음으로 찾아내는 증명 기법  
대개 어떤 선택이 항상 최선임을 증명하고자 할 때 많이 이용한다. ex) 최단 경로 찾기  
> <책장 쌓기>  
>   
> 각 책장마다 버틸 수 있는 최대 무게 M<sub>i</sub>와 자신의 무게 W<sub>i</sub>가 주어졌을 때, 책장 위에 올라간 다른 책장들의 무게의 합이 견딜 수 있는 최대 무게를 초과하면 안된다. 책장을 쌓는 순서를 최대 무게와 자신의 무게의 합(M<sub>i</sub>+W<sub>i</sub>)가 큰 것부터 아래에 놓아야 할까?  
>  
> => 가정과 반대로, M<sub>i</sub>+W<sub>i</sub>가 더 큰 책장 A가 더 작은 책장 B 위에 올라간 형태라고 가정한다. 이때 A와 B의 위치를 항상 바꿀 수 있음을 증명한다. 그러면 M<sub>i</sub>+W<sub>i</sub>가 큰 것이 밑에 가도록 책장을 쌓아도 최선의 답을 얻을 수 있다는 증거가 된다.    
>  
> 가정대로 M<sub>A</sub>+W<sub>A</sub> > M<sub>B</sub>+W<sub>B</sub> 식에서 M<sub>A</sub>만을 좌변에 남긴다. M<sub>A</sub> > M<sub>B</sub>+W<sub>B</sub>-W<sub>A</sub>  
> A위의 상자들의 무게의 합을 X라고 하면 A가 B위에 올라갔으니 M<sub>B</sub> >= W<sub>A</sub>+X  
> 두 식을 합치면 M<sub>A</sub> > M<sub>B</sub>+W<sub>B</sub>-W<sub>A</sub> >= (W<sub>A</sub>+X)+W<sub>B</sub>-W<sub>A</sub>  
> 맨 오른쪽 식을 정리하면 M<sub>A</sub> > X + W<sub>B</sub>  
>  
> 마지막 식의 의미는 A도 B와 나머지 모든 상자들을 지탱할 수 있다는 말이므로 M<sub>i</sub>+W<sub>i</sub>가 큰 것부터 아래에 놓아도 최선의 경우를 얻을 수 있다.

### 다른 기술들
#### 비둘기집의 원리
10마리의 비둘기가 9개의 비둘기집에 모두 들어갔다면, 2마리 이상이 들어간 비둘기집이 반드시 하나는 있게 마련이다.  
> 머리털을 넉넉하게 잡아 100만 가닥이라고 하면, 서울의 천만 인구 중 머리털 개수가 정확이 같은 두 사람은 반드시 존재한다.

#### 구성적 증명
답의 실제 예를 들거나 답을 만드는 방법을 실제로 제시하는 증명  
> 하늘을 나는 교통 수단을 만들 수 있다는 주장은 비행기를 만들어 보여주거나, 비행기 만드는 법이 적힌 설명서를 건네 주는 것이다.

---
#algorithm/알고리즘문제해결전략